## 04장 변수
---

### 4.1 변수란 무엇인가? 왜 필요한가?

> `변수` 는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.

다음과 같은 JS 코드를 살펴보자.

```jsx
10 + 20;
```

자바스크립트 엔진은 위 코드를 평가하기 위해 10,20,+ 라는 기호를 알고 있어야 하며, 10 + 20 이라는 표현식의 의미도 해석(parsing) 할 수 있어야 한다.

자바스크립트 엔진이 + 연산을 수행하기 위해 먼저 피연산자(operand) 10,20 을 기억해야 한다. 컴퓨ㄴ터는 이를 메모리에 저장하고 읽는다. CPU는 메모리에 있는 피연산자를 읽어 + 연산을 수행한 뒤 30이라는 값을 다른 메모리 공간에 저장한다.

하지만 이대로는 `30` 이라는 메모리 주소에 직접 접근하는 것 말고는 `30` 이라는 값을 사용할 수 없다. JS는 개발자가 메모리에 직접 접근하도록 허용하지 않으므로 `30` 이라는 값에 결과적으로는 접근할 수 없다.

이러한 문제점을 해결하기 위해서 `변수` 라는 개념이 존재한다.

```jsx
var result = 10 + 20;
```

10 + 20을 통한 연산의 결과를 `result` 라는 메모리 공간에 붙여진 `이름` 을 통해 저장하여 재사용할 수 있게 된다. 이렇듯 변수에 값을 저장하는 것을 `할당` 이라 하고, 변수에 저장된 값을 읽어 들이는 것을 `참조` 라고한다.

### 4.2 식별자
> `식별자` 는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.

값은 메모리 공간에 저장되어있다. 따라서 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별하는 역할을 수행해야한다. 이를 위해 식별자는 어떤 값이 저장되어 있는 메모리 주소를 기억해야 할 필요가 있다. 

즉 식별자는 `값` 이 아니라 `메모리 주소` 를 기억하고 있는 것이다. 변수, 함수, 클래스 등의 이름은 모두 `식별자` 이다. 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름을 모두 `식별자` 라고 부를 수 있는 것

변수,함수,클래스 등의 이름과 같은 식별자는 `네이밍 규칙` 을 준수해야 하고, 선언에 의해 JS. 엔진에 식별자의 존재를 알릴 수 있다.

### 4.3 변수 선언

> `변수 선언` 이란 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding) 해서 값을 저장할 수 있게 준비하는 것을 말한다.

변수를 사용하려면 이전에 반드시 `선언` 이 필요하다. 변수를 선언할 때는 `var` , `let` , `const` 키워드를 사용한다. 여기서 `let` `const` 키워드는 ES6에서 도입되었는데, 

> 키워드는 JS 코드를 해석하고 실행하는 JS 엔진이 수행할 동작을 규정한 일종의 명령어라고 할 수 있다.

> ES5 VS ES6 기존의 var 키워드는 여러 단점이 있었다. block-level-scope 를 지원하지 않고 function-level-scope 를 지원한다는 것.

```jsx
var score;
```

변수 선언에 의해 확보된 `메모리 공간` 은 비어 있을 것으로 생각할 수 있으나, `확보된 메모리 공간` 에는 JS 엔진에 의해 `undefined` 라는 값이 암묵적으로 `할당` 되어 `초기화` 된다. 

JS 엔진은 변수 선언을 다음과 같은 두가지 단게를 거쳐서 수행한다.

* 선언 단계 - 변수 이름을 등록해서 JS 엔진에 변수의 존재를 알린다.
* 초기화 단계 - 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined` 를 할당해 초기화 한다.

초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 어플리케이션이 사용했던 값이 남아있을 수 있다. 이러한 값을 `쓰레기 값` 이라고 한다. 하지만 JS는 암묵적으로 초기화를 수행하므로 이런 위험이 없다.

JS 에서는 `선언하지 않은 식별자` 에 접근하면 `ReferenceError(참조 에러)` 가 발생한다

> JS는 컴파일 언어이다 실행되기 전에 `microsecond` 동안 컴파일 됨

`var a = 2;` 라는 코드를 예시로 들어보자, 

1. 컴파일러는 `var` 키워드를 보고 Scope 에 해당 변수 선언을 요청한다. 그 후 엔진이 실행할 수 있는 코드를 생성한다. `a = 2`
2. 프로그램 실행 후 `a = 2` 를 만난 JS 엔진은 Scope 에서 해당 `a` 를 찾고 값을 할당하는 일을 한다.

### 4.4 변수 선언의 실행 시점과 변수 호이스팅

```jsx
console.log(score) //undefined
var score;
```

위 코드에서 `참조에러` 가 발생하지 않고 `undefined` 가 출력이 되는 이유는 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문이다. 

JS 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 한다. 

이때, 소스코드 실행을 위한 준비 단계인 소스코드의 평가 과정에서 JS 엔진은 변수 선언을 포함한 모든 선언문 (변순,선언문,함수 선언문등)을 소스코드에서 찾아내 먼저 실행한다.

그리고 소스코드의 평가 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다. 즉, JS엔진은 변수 선언이 어디에 위치하든 상관없이 다른 코드보다 먼저 실행하는 것이다. 

이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 JS 고유의 특징을 변수 `호이스팅` 이라고 한다.

### 값의 할당
---

변수에 값을 할당할 때는 `할당 연산자 = ` 를 사용한다. 할당 연산자는 우변의 값을 좌변의 변수에 할당하는 역할을 하는데, 변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 `값의 할당` 은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.

```jsx
console.log(score) //undefined

var score;
score = 80;
console.log(score) //80
```
변수에 값을 할당할 때는 이전 값 `undefined`가 저장되어 있는 메모리 공간을 지우고 그 메모리 공간에 할당 값 80을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값 `80` 을 저장한다.

### 값의 재할당
---
`재할당` 이란 이미 값이 할당되어 있는 변수에 새로운 값을 또 다시 `할당` 하는 것을 말한다. var 키워드로 선언한 변수는 선언과 동시에 `undefined` 로 초기화되기 때문에 엄밀히 말하자면 변수에 처음으로 값을 할당하는 것도 사실은 `재할당` 이다.

값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 `상수` 라고 한다.

`상수` 는 단 `한 번만` 할당할 수 있는 변수를 말한다. 변수에 값을 재할당 할 때에는 처음에 변수에 값을 할당할 때 처럼 이전 값이 저장되어 있던 메모리 공간에 새로운 값을 저장하는 것이 아니라 `새로운 메모리 공간` 을 확보하고 그 메모리 공간에 새로운 값을 저장하는 것이다. 

이후, 어떤 식별자와도 연결되어 있지 않은 불필요한 값들은 `가비지 컬렉터` 에 의해 메모리에서 자동 해제된다. 단 메모리에서 `언제` 해제 될지는 예측할 수 없다.

---
[가비지컬렉터란 ?](https://velog.io/@gawgjiug/%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98)
